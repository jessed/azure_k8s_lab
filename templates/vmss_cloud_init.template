#!/bin/bash

# BIG-IP ONBOARD SCRIPT
# azurerm will copy this to /var/lib/waagent/CustomData and execute
# source wait_bigip_ready* functions
source /usr/lib/bigstart/bigip-ready-functions

DEBUG=0

### Variables
admin_user='${admin_user}'
admin_password='${admin_password}'
CREDS="${admin_user}:${admin_password}"
cfg_dir='${CFG_DIR}'
blob_headers="$cfg_dir/blob_headers.txt"
cloud_init_log=${cloud_init_log}
rpms_dir="$cfg_dir/rpms"

use_bigiq_license='${use_bigiq_license}'
use_blob='${use_blob}'
BLOB_PATH='${BLOB}'
DO_FN='${DO_FN}'
AS3_FN='${AS3_FN}'
TS_FN='${TS_FN}'

# DO variables
doUrl="mgmt/shared/declarative-onboarding"
doInfoUrl="mgmt/shared/declarative-onboarding/info"
doTaskUrl="mgmt/shared/declarative-onboarding/task"

# AS3 variables
as3Url="mgmt/shared/appsvcs/declare"
as3InfoUrl="mgmt/shared/appsvcs/info"
as3TaskUrl="mgmt/shared/appsvcs/task"

# TS variables
tsUrl="mgmt/shared/telemetry/declare"
tsInfoUrl="mgmt/shared/telemetry/info"
tsTaskUrl="mgmt/shared/telemetry/task"

iAppInstallUrl="http://localhost:8100/mgmt/shared/iapp/package-management-tasks"
metadataUrl="http://169.254.169.254/metadata/instance?api-version=2021-02-01"

servers='${servers}'

### /Variables

### Functions
# Wait for VE to become active
# This is necessary following reprovisioning, and none of the
# wait_bigip_ready* functions actually wait for active
wait_bigip_active() {
  status_file=/var/prompt/ps1
  while [[ true ]]; do
    test -f $status_file && { ve_status=$(cat $status_file); }
    if [[ $ve_status == "Active" ]]; then
      echo "$(date +%T): BIG-IP Active"
      return
    fi
    sleep 10
  done
}
### /Functions

# wait for bigip to become ready for configuration
sleep 60
wait_bigip_ready

# onboard and cloud configuration working directory
mkdir -p $cfg_dir
mkdir -p $rpms_dir
ln -s $cfg_dir /home/$admin_user/ 2>/dev/null

## * Update STDOUT and STDERR
LOG_FILE="$cfg_dir/$cloud_init_log"
if [[ ! -e $LOG_FILE ]]; then
  touch $LOG_FILE
  exec &>>$LOG_FILE
else
  #if file exists, exit as only want to run once
  exit
fi
exec 1>$LOG_FILE 2>&1

# copy onboard script $cfg_dir for ease of review
echo "$(date +%T) cp $0 $cfg_dir/cloud_init_script.bash && chmod 755 $cfg_dir/cloud_init_script.bash"
cp $0 $cfg_dir/cloud_init_script.bash && chmod 755 $cfg_dir/cloud_init_script.bash

# Enable debug output
if [[ $DEBUG > 0 ]]; then set -x; fi

do_config_b64='${DO_conf}'

as3_config_b64='${AS3_conf}'

ts_config_b64='${TS_conf}'

#ltm_config_b64='${ltm_config}'
#ltm_cfg_blob='${ltm_cfg_blob}'
ltm_cfg_url='${ltm_cfg_url}'

lic_update_b64='${license_update}'

update_license_b64='${systemd_licensing}'

do_cfg="$cfg_dir/do_cfg.json"
ts_cfg="$cfg_dir/ts_cfg.json"
as3_cfg="$cfg_dir/as3_cfg.json"
ltm_cfg="$cfg_dir/ltm_cfg.conf"
lic_update="$cfg_dir/f5_update_license.bash"
update_license="$cfg_dir/f5_update_license.service"

###
### Begin Main
# Update ${admin_user} password to allow REST calls and GUI access
tmsh modify auth user ${admin_user} password '${admin_password}'

# If an ltm_cfg_url was provided, download it now before the DO config 
# is applied
if [[ $ltm_cfg_url ]]; then
  echo "$(date +%T) Retrieving bigip.conf from $ltm_cfg_url"
  curl -s $ltm_cfg_url -o $ltm_cfg
fi


## Get Azure-assigned data-plane IP address from metadata
# Get data-plane nic mac-address
while [[ true ]]; do
  ((count++))
  dataNicMac=$(tmsh show net interface 1.1 all-properties | awk '/uninit/ { print toupper($3) }' | sed 's/://g')
  if [[ -n $dataNicMac && ! $dataNicMac =~ "NONE" ]]; then break; fi
  if (( count > 30 )); then
    echo "$(date +%T) Failed to find data nic mac address."
    dataNicMacErr=1
    break
  fi
  sleep 1
done


if [[ $dataNicMacErr ]]; then
  echo "$(date +%T) ERROR: Failed to get data-plane mac address"
  tmsh show net interfaces all-properties >> $cfg_dir/$cloud_init_log
  exit 1
fi
echo "$(date +%T) Found data-plane mac address: $dataNicMac"

# filter assigned addresses by data-plane mac
jqAddrFilter=".network.interface[] | select(.macAddress == \"$dataNicMac\") | .ipv4.ipAddress[0].privateIpAddress"
jqMaskFilter=".network.interface[] | select(.macAddress == \"$dataNicMac\") | .ipv4.subnet[0].prefix"

self_ip=$(curl -sH Metadata:true $metadataUrl | jq -r "$jqAddrFilter")
netmask=$(curl -sH Metadata:true $metadataUrl | jq -r "$jqMaskFilter")
host=$(curl -sH Metadata:true $metadataUrl | jq -r .compute.osProfile.computerName)

if [[ -z $self_ip || -z $netmask ]]; then
  echo "$(date +%T) ERROR: Failed to find data-plane self-ip or netmask for mac address '$dataNicMac'."
  echo "$(date +%T) ERROR: self_ip: '$self_ip', mask: '$netmask'"
  exit 1
fi

echo "$(date +%T) Found self-ip: $self_ip/$netmask"
echo "$(date +%T) Found hostname: $host"

# If a storage blob is being used, assume an identity is required
# If not, just attempt to download the files using the given filename
if [[ $use_blob == 1 ]]; then
  # Get our storage access token and build authorization header
  tokenUrl="http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://storage.azure.com/"
  storageToken=$(curl -0s -H "Metadata:true" $tokenUrl | jq -r ".access_token")
  echo "x-ms-version: 2017-11-09" > $blob_headers
  echo "Authorization: Bearer $storageToken" >> $blob_headers

  if [[ -n $ltm_cfg_blob ]]; then
    echo -e "$(date +%T) Downloading $BLOB_PATH/$ltm_cfg_blob"
    echo $(date +%T) curl -LsH "$(cat $blob_headers)" $BLOB_PATH/$ltm_cfg_blob -o $ltm_cfg
    curl -vLsH "$(cat $blob_headers)" $BLOB_PATH/$ltm_cfg_blob -o $ltm_cfg
    #TODO: add sed command to substitute the self-ip for '__self_ip__' in the blob file
    #      then load the config
    #sed -i   "s/__self_ip__/$SELF_IP/" $ltm_cfg
    #tmsh load sys config $ltm_cfg merge
  fi

  ###
  ### Download iAppLX packages; wait for each to complete it's installation
  for file in $AS3_FN $DO_FN $TS_FN; do
    echo -e "$(date +%T) Downloading $file"
    echo $(date +%T) curl -LsH "$(cat $blob_headers)" $BLOB_PATH/$file -o $rpms_dir/$file
    curl -vLsH "$(cat $blob_headers)" $BLOB_PATH/$file -o $rpms_dir/$file 2>$cfg_dir/curl_$${file}.log
    # Not downloading checksum file because files in BLOB are pre-staged
    if [[ $? == 0 ]]; then rm $cfg_dir/curl_$${file}.log; fi
  done

else
  for uri in $AS3_FN $DO_FN $TS_FN; do
    file=$(basename $uri)
    if [[ -f $rpms_dir/$file ]]; then
      echo "$(date +%T) File $rpms_dir/$file already present - skipping download"
      continue
    fi
    echo "$(date +%T) Downloading: $file"
    echo $(date +%T) curl -Ls $uri -o $rpms_dir/$file
    curl -Ls $uri -o $rpms_dir/$file 2>/$cfg_dir/curl_$${file}.log
    curl -Ls $uri.sha256 -o $rpms_dir/$file.sha256 2>>/$cfg_dir/curl_$${file}.log
    shaCalc=$(shasum -a 256 $rpms_dir/$file | awk '{print $1}')
    shaRead=$(cat $rpms_dir/$file.sha256 | awk '{print $1}')

    if [[ $shaCalc != $shaRead ]]; then
      echo "$(date +%T) ERROR: Calculated checksum ($shaCalc) does not match downloaded checksum ($shaRead) for file $file"
      #rm $rpms_dir/$file
    else
      echo "$(date +%T) Checksums match for file $file"
      rm $cfg_dir/curl_$${file}.log $rpms_dir/$file.sha256
    fi
  done
fi

# restart restnoded in preparation for installing rest packages
tmsh restart sys service restnoded
sleep 15

# Create config files (json and conf) from base64
# Declarative Onboarding
if [[ -n $do_config_b64 ]]; then echo $do_config_b64 | base64 -d > $do_cfg; fi

# Telemetry Streaming
if [[ -n $ts_config_b64 ]]; then echo $ts_config_b64 | base64 -d > $ts_cfg; fi

# AS3 config
if [[ -n $as3_config_b64 ]]; then echo $as3_config_b64 | base64 -d > $as3_cfg; fi

# Install REST packages
for pkg in $AS3_FN $DO_FN $TS_FN; do
  file=$(basename $pkg)
  if [[ ! -f $rpms_dir/$file ]]; then
    echo "$(date +%T) $rpms_dir/$file not present, skipping package install"
    continue
  fi
  cp $rpms_dir/$file /var/config/rest/downloads

  echo "Install REST package: $file"
  service=$(echo $file | cut -d '-' -f 2)
  if [[ $service =~ "declarative" ]]; then service="declarative-onboarding"; fi

  DATA=$(printf '{"operation":"INSTALL","packageFilePath":"%s"}' /var/config/rest/downloads/$file)
  echo "$(date +%T) curl -su '$CREDS' -X POST $iAppInstallUrl -d $DATA"
  curl -su $CREDS -X POST $iAppInstallUrl -d $DATA -o $cfg_dir/$${service}_install.log

  for (( cnt=0; $cnt < 20; cnt++ )); do
    #STATUS=$(curl -Isku $CREDS https://localhost/mgmt/shared/$service/info | awk '/^HTTP/ { print $2 }')
    STATUS=$(curl -sku $CREDS -w "%%{http_code}" https://localhost/mgmt/shared/$service/info -o /dev/null)
    if [[ $STATUS == 200 ]]; then
      pkgStatus=1
      rm /var/config/rest/downloads/$file
      rm $cfg_dir/$${service}_install.log
      break
    else
      echo -e "$(date +%T) Status code: $STATUS package install in-progress ($file)"
    fi
    sleep 10
  done

  if [[ $pkgStatus == 1 ]]; then
    echo -e "$(date +%T) $service install completed"
  else
    echo -e "$(date +%T) $service package install FAILED"
  fi
done


######################################
#### POST DO and TS Declarations ####
######################################

# restart restnoded before applying DO config
tmsh restart sys service restnoded
sleep 20

echo "$(date +%T) Checking restnoded status"
for (( CNT=0; $CNT < 60; CNT++)); do
  doStatus=$(curl -sku $CREDS https://localhost/$doInfoUrl | jq -r '.[].result.code' 2>$cfg_dir/do_check_error.log)
  if [[ $doStatus == 200 ]]; then
    echo "$(date +%T) DO available, proceeding"
    break
  else
    echo "$(date +%T) DO not available"
  fi
  sleep 3
done


if [[ $doStatus == 200 ]]; then
  # Update self-ip in ltm config file
  echo "$(date +%T) Updating self-ip to $self_ip"
  sed -i  "s/__SELF_IP__/$self_ip/" $do_cfg
  sed -i  "s/__NETMASK__/$netmask/" $do_cfg

  # update DO config before posting
  echo "$(date +%T) Updating hostname to $host"
  sed -i  "s/__HOSTNAME__/$host.westus2.cloudapp.azure.com/" $do_cfg

  # Submit DO Declaration
  echo -e "$(date +%T) Submitting DO declaration"
  echo curl -sku $CREDS -X POST https://localhost/$doUrl -d @$do_cfg -o $cfg_dir/do_task_out.json
  curl -sku $CREDS -X POST https://localhost/$doUrl -d @$do_cfg -o $cfg_dir/do_task_out.json
  doTaskId=$(cat $cfg_dir/do_task_out.json | jq -r '.id')
  
  # Wait for the DO task to complete
  for (( CNT=0; $CNT < 30; CNT++ )); do
    RESP=$(curl -sku $CREDS https://localhost/$doTaskUrl/$doTaskId)
    CODE=$(echo $RESP | jq .result.code 2>/dev/null)

    # Make sure $CODE is populated before trying to check it
    if [[ -z $CODE ]]; then
      echo $RESP > $cfg_dir/doTaskStatus.json
      sleep 10
      continue
    fi
    if (( $${CODE:-0000} == 200 )); then
      echo "$(date +%T) DO task successful"
      test -f $cfg_dir/doTaskStatus.json && rm $cfg_dir/doTaskStatus.json
      break
    elif (( $${CODE:-0000} == 202 )); then
      echo -e "$(date +%T) DO task still in-progress"
    elif (( $${CODE:-0000} >= 400 )); then
      echo -e "$(date +%T) DO task still failed, code: $CODE"
      break
    else
      echo -e "$(date +%T) DO task status unknown (code $CODE)"
    fi
    sleep 10
  done

else
  echo "$(date +%T) *** DO INSTALLATION FAILED ***"
fi

# Submit TS Declaration
if [[ -f $ts_cfg ]]; then
  echo "$(date +%T) Finding VM instance resource ID"
  resource_id=""
  good_response="subscriptions"
  until [[ $resource_id =~ $good_response ]]; do
    resource_id=$(curl -sH Metadata:true "http://169.254.169.254/metadata/instance/compute/resourceId?api-version=2020-09-01&format=text")
    sleep 1
  done
  echo "$(date +%T) Found Resource ID: $resource_id"
  echo "$(date +%T) Updating TS configuration"
  sed -i  's#__resource_id__#'"$resource_id"'#' $ts_cfg

  echo -e "$(date +%T) Submitting TS declaration"
  echo curl -sku '$CREDS' -H "Content-Type: Application/json" -X POST https://localhost/$tsUrl -d @$ts_cfg -o $cfg_dir/ts_status.json
  curl -sku $CREDS -H "Content-Type: Application/json" -X POST https://localhost/$tsUrl -d @$ts_cfg -o $cfg_dir/ts_status.json
  echo -e "$(date +%T) ===Telemetry Streaming configuration complete==="
else
  echo -e "$(date +%T) TS declaration file ($ts_cfg) not present; not submitting TS declaration"
fi

# Only run AS3 task if AS3 has been provided
if [[ -f $as3_cfg ]]; then
  echo -e "\n"$(date +%T) "Submitting AS3 declaration"
  echo $(date +%T) curl -sku '$CREDS' -H "Content-Type: Application/json" -X POST https://localhost/$as3Url -d @$as3_cfg
  curl -sku $CREDS -H "Content-Type: Application/json" -X POST https://localhost/$as3Url -d @$as3_cfg
fi

###
### Install the LTM configuration

# DO network config won't succeed if certain network elements exist,
# so we need to make sure the system is active before proceeding.
# NOTE: This command will never return if the system never goes active
# TODO: Should probably perform the check in a loop to avoid an infinite wait
#       if licensing fails
echo "$(date +%T) Waiting for bigip to become active"
wait_bigip_active
echo -e "$(date +%T) Ready to receive post-onboarding configuration\n"

# Make sure the vlan is present. If not, the DO config hasn't actually finalized.
for (( count=0; count < 30; count++ )); do
  vlans=$(tmsh list net vlan one-line 2>/dev/null | wc -l)
  if (( $vlans > 0 )); then
    echo "$(date +%T) Vlans found, loading configuration elements"
    break
  else
    echo "$(date +%T) Waiting for DO to complete (vlan count: $vlans)"
  fi
  sleep 5
done
if (( $vlans == 0 )); then echo "$(date +%T) ERROR: No vlans not found, DO config load failed"; fi


##
## Import LTM configuration
# Write LTM config to file for merging

# Retrieve ltm config if provided as a b64
if [[ -n $ltm_config_b64 && (($vlans > 0)) ]]; then echo $ltm_config_b64 | base64 -d > $ltm_cfg; fi

# Retrieve ltm config if provided as a URL
if [[ $ltm_cfg_url ]]; then
  # generate pool configuration from server list
  pool_cfg="ltm pool p01-remote_ssl {\n  members {\n"
  for s in $servers; do pool_cfg="$pool_cfg     $s:443\n"; done
  pool_cfg="$pool_cfg  }\n}\n"

  sed -i  "s/__POOL_CFG__/$pool_cfg/" $ltm_cfg



  # Update self-ip in ltm config file
  sed -i  "s/__VS_ADDR__/$self_ip/" $ltm_cfg
fi

# Load the LTM configuration
if [[ -f $ltm_cfg ]]; then
  tmsh load sys config file $ltm_cfg merge verify >/dev/null 2>&1
  if [[ $? == 0 ]]; then
    echo "$(date +%T) LTM config verify successful; loading LTM configuration"
    tmsh load sys config file $ltm_cfg merge >/dev/null 2>&1
  else
    echo "$(date +%T) LTM config verify encountered errors; not loading ltm configuration"
  fi
fi
## LTM import complete


## Systemd Licensing service
## Create systemd service to release the license on shutdown and relicense on boot
if [[ $use_bigiq_license == 1 ]]; then
  # create license revocation script in /etc/init.d and symlink to rc scripts
  if [[ -n $lic_update_b64 ]]; then echo $lic_update_b64 | base64 -d > $lic_update; fi
  if [[ -n $update_license_b64 ]]; then echo $update_license_b64 | base64 -d > $update_license; fi

  chmod 755 $lic_update
  cp $lic_update /etc/init.d

  # create systemd service
  cp $update_license /etc/systemd/system/
  systemctl daemon-reload
  systemctl enable f5_update_license
  systemctl start f5_update_license
fi  
## /Systemd Licensing service

###
### Clean up

# Remove RPMs
#rm $rpms_dir/*rpm

echo "$(date +%T) Saving configuration"
tmsh save sys config

# update syslog-ng to stop logging to the console
# NOTE: This isn't actually necessary, but console logging bugs me, so...
echo "$(date +%T) Redirectong console log messages to /var/log/console.log"
sed -i -e 's/usertty(\"\*\")/file("\/var\/log\/console.log")/' /var/run/config/syslog-ng.conf
tmsh restart sys service syslog-ng

exit 0


# set vim: set syntax=sh tabstop=2 expandtab:
